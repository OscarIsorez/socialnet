import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:socialnet/presentation/bloc/auth/auth_state.dart';

import '../../../domain/entities/conversation.dart';
import '../../../domain/entities/message.dart';
import '../../../domain/entities/user.dart';
import '../../bloc/auth/auth_bloc.dart';
import '../../bloc/messaging/messaging_bloc.dart';
import '../../widgets/messaging/message_input.dart';
import '../../widgets/messaging/messages_list.dart';

class ChatPage extends StatefulWidget {
  const ChatPage({
    super.key,
    this.conversationId,
    this.otherUserId,
    this.conversation,
    this.currentUser,
    this.participants = const [],
  });

  final String? conversationId;
  final String? otherUserId;
  final Conversation? conversation;
  final User? currentUser;
  final List<User> participants;

  @override
  State<ChatPage> createState() => _ChatPageState();
}

class _ChatPageState extends State<ChatPage> {
  final TextEditingController _messageController = TextEditingController();

  String get _currentUserId {
    // Use the provided currentUser if available
    if (widget.currentUser != null) {
      return widget.currentUser!.id;
    }

    final authState = context.read<AuthBloc>().state;
    if (authState is Authenticated) {
      return authState.user.id;
    }
    return 'unknown-user'; // Fallback
  }

  @override
  void initState() {
    super.initState();
    _initializeChat();
  }

  void _initializeChat() {
    // If conversation object is provided directly, set it in the bloc state
    if (widget.conversation != null) {
      // If we have a conversation object, we can directly start watching its messages
      context.read<MessagingBloc>().add(
        WatchMessages(conversationId: widget.conversation!.id),
      );
    } else if (widget.conversationId != null) {
      // Load existing conversation by ID
      context.read<MessagingBloc>().add(
        WatchMessages(conversationId: widget.conversationId!),
      );
    } else if (widget.otherUserId != null) {
      // Create or get conversation with other user
      context.read<MessagingBloc>().add(
        GetOrCreateConversation(
          participantIds: [_currentUserId, widget.otherUserId!],
        ),
      );
    }
  }

  @override
  void dispose() {
    _messageController.dispose();
    super.dispose();
  }

  void _sendMessage() {
    final content = _messageController.text.trim();
    final currentConversation =
        widget.conversation ??
        context.read<MessagingBloc>().state.currentConversation;
    if (content.isEmpty || currentConversation == null) return;

    String? receiverId;
    if (currentConversation.isIndividual) {
      try {
        final otherParticipantId = currentConversation.participantIds
            .firstWhere((id) => id != _currentUserId, orElse: () => '');
        receiverId = otherParticipantId.isNotEmpty ? otherParticipantId : null;
      } catch (e) {
        print('Error finding receiver: $e');
        receiverId = null;
      }
    }

    final newMessage = Message(
      id: '', // Will be generated by Firebase
      senderId: _currentUserId,
      conversationId: currentConversation.id,
      content: content,
      timestamp: DateTime.now(),
      type: MessageType.text,
      receiverId: receiverId,
    );

    context.read<MessagingBloc>().add(SendMessage(message: newMessage));
    _messageController.clear();
  }

  String _getChatTitle(Conversation? conversation) {
    // Use provided conversation first, then fall back to state
    final currentConversation = widget.conversation ?? conversation;

    if (currentConversation == null) return 'Loading...';

    if (currentConversation.isGroup) {
      return currentConversation.groupName ?? 'Group Chat';
    }

    // For individual chats, try to find the other participant
    // Use provided participants first, then try to get from state
    if (widget.participants.isNotEmpty) {
      try {
        final otherParticipant = widget.participants.firstWhere(
          (user) => user.id != _currentUserId,
          orElse: () => widget.participants.first,
        );
        return otherParticipant.profileName;
      } catch (e) {
        // Fall through to default handling
      }
    }

    // Fallback: try to find other participant by ID
    try {
      final otherParticipantId = currentConversation.participantIds.firstWhere(
        (id) => id != _currentUserId,
        orElse: () => '',
      );

      if (otherParticipantId.isEmpty) {
        return 'Chat';
      }

      // TODO: Implement user name lookup from participant cache or user repository
      return 'Chat'; // Placeholder - implement user name lookup
    } catch (e) {
      return 'Chat';
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<MessagingBloc, MessagingState>(
      builder: (context, state) {
        final currentConversation =
            widget.conversation ??
            state.currentConversation ??
            state.createdConversation;

        return Scaffold(
          appBar: AppBar(
            title: Text(_getChatTitle(currentConversation)),
            actions: [
              if (currentConversation?.isGroup == true)
                IconButton(
                  icon: const Icon(Icons.info_outline),
                  onPressed: () {
                    // Navigate to group info
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Group info coming soon')),
                    );
                  },
                ),
            ],
          ),
          body: BlocListener<MessagingBloc, MessagingState>(
            listener: (context, state) {
              if (state.createdConversation != null &&
                  currentConversation == null) {
                // New conversation was created/found, start watching its messages
                context.read<MessagingBloc>().add(
                  WatchMessages(conversationId: state.createdConversation!.id),
                );
              }

              if (state.isFailure) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(state.message ?? 'An error occurred')),
                );
              }
            },
            child: _buildBody(state, currentConversation),
          ),
        );
      },
    );
  }

  Widget _buildBody(MessagingState state, Conversation? currentConversation) {
    // If we have a provided conversation, we don't need to wait for bloc loading
    final hasProvidedConversation = widget.conversation != null;

    if (state.isLoading &&
        currentConversation == null &&
        !hasProvidedConversation) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.isFailure &&
        currentConversation == null &&
        !hasProvidedConversation) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 48, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text(
              state.message ?? 'Failed to load chat',
              style: TextStyle(color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _initializeChat,
              child: const Text('Try Again'),
            ),
          ],
        ),
      );
    }

    return Column(
      children: [
        Expanded(
          child: MessagesList(
            messages: state.currentMessages,
            currentUserId: _currentUserId,
            isGroupChat: currentConversation?.isGroup ?? false,
          ),
        ),
        if (currentConversation != null)
          MessageInput(
            controller: _messageController,
            onSend: _sendMessage,
            hintText: currentConversation.isGroup
                ? 'Message ${currentConversation.groupName ?? 'group'}...'
                : 'Message ${_getChatTitle(currentConversation)}...',
          ),
      ],
    );
  }
}
